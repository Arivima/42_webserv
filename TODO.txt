TO DO 

	Matteo
		1-	Finire Chunked Encoding cgi
			1.2-	&& studiare body_size con chunked encoding
		2-	Change req url name to "uri"
		3-	Config : overwrite multi-valued directive if it comes from outer block
		-check for every member that should be a reference
		- (forse)togliere set buffer size del socket nel Worker (setsockopt)
		4. SEND Server Internal Error on SockEof (pensare se fare cosí)


	Arielle
		-	test body size
		-	test redirections		
			- gestire direttamente in generateResponse
				1.	verificare che matching_directives.directives.find("redirect")
				2.	Se si, rispondere con un messaggio http redirect (studiare)
				3.	--da gestire in generateResponse, quindi NON in GET, POST, DELETE

		1-	Timers

		Final cleaning : 
			-	clean exceptions / error syntax to make it consistent throughout files
			-	clean all unuseful comments
			-	put all implementations in .cpp
			-	clean webserv.hpp and utils.cpp		
		4-	cgi script for file Upload



	TESTING
		-	Check against subject, correction sheet, tester, write tests with python, Postman 
		-	fare correction sheet e scrivere una lista de tutte le cose da dimonstrare
		- SIEGE
		- leaks


	check
		• what happens if 10 clients try to upload 1G of data -> running out of memory cases
		• Your server must be compatible with the web browser of your choice.
		• Stress tests your server. It must stay available at all cost.
		- Checkt that ANY fd read goes through epoll
		- Check UNKNOWN request

	Additional tasks if there is time:
		- fare un log
		- cookie ?
		-	update Webserv.doc








Timers Idea (devo studiarlo meglio)

		STUDIARE
			1-	HTTP 504 Gateway Timeout (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504)
			2-	

		class :	ConnectionSocket && usare Exceptions.hpp getErrorPage()
				e poi chiudere la connessione nel Worker (vedi sotto)
		function : serve_client()

		workflow : serve_client---->throw HttpError---->Worker::_serve_clientS
															--->getErrorPage,
															send and close connection.

		idea :
			1.	prima di fare parse_line() o send_line(),
				controllare che elapsed_time < tempo scelto (scegliere un tempo--studiare)
			2.	Se il tempo é >, throw HttpError()


		quali timers ? clock_gettime (#include <time.h>)
			-Example. (https://github.com/mmarinel/42RomaLuiss__Cpp09.git) ex02/main.cpp



















///////////////////////////////////////////////////////////////////////////////////////////////////////

Matteo
	13	valutare se contollare la presenza di location block ripetuti

To assign
	1.	implementare redirections in GET
	9.	Check compatibility with Chrome/Firefox (set right headers)

Meno Prioritario
	1	refactoring HttpError ----> usare vector of char
		-forse, in HttpError chiudere la connessione dopo aver ritornato un errore


Config file:
	1. host directive
	2. client body_size
	3. routes
		3.1 accepted methods
		3.2 redirection
		3.3 autoindex
		3.4	directive for uploading files
		3.4 CGI


ARCHIVES not yet done but useless (maybe) !
	3.util : fare funzione che, presa una stringa, rimuove tutti i caratteri a partire da uno dato,
		se esiste nella stringa.


to short
//TODO Request.hpp
//TODO	1.	Write Request.cpp...continue refactoring (making of Request class)
//TODO	2.	change req map as being object not ref inside Response
//TODO	3.	write switch_state function in ConnectionSocket (pay attention first creating the new
//TODO		and then deleting the old one as the new may need results from the old)
//TODO	4. use exceptions in types.h (remove SockEof and other exceptions inside classes
//TODO	ConnectionSocket, Request and Response )
//TODO	5. handle SockEof exception inside Worker serve_clientS loop. (Not inside ConnectionSocket!)
//TODO	6. Refactor ConenctionSocket.
//TODO
//TODO


//////////////////////////////////////////////////////////////////////////////////////////////////

TroubleShooting

Ideas

Matteo
Idea per handling binary data in body of request
	1.	Splitta body e request
		1.1	request resta una mappa
		1.2	body diventa un vector<char>
	2.	Request
		2.1	Sostituisci gli stream con vector di char
			2.1.1	recv_buf resta un array
			2.1.2	vector<char> sostituisce lo stream e ci dumpiamo il contenuto letto dal buffer
				2.1.2.1	possiamo usare le funzioni find(), erase(), etc. di vector per sostuire getline
			2.1.3	passiamo il body e la richiesta alle varie classi come due variabili diverse
			2.1.4	per scrivere il body in un file, apriamo il file con ofstream e open_mode std::ios_binary
					e usiamo basic_ostream& write( const char_type* s, std::streamsize count )
					con body.data() come const char*
					e body.size() come count
